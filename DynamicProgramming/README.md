- [DynamicProgramming 动态规划](#dynamicprogramming-动态规划)
- [钢条切割 CutRod](#钢条切割-cutrod)
- [最大连续子数组之和](#最大连续子数组之和)
- [最大连续子数组](#最大连续子数组)

# DynamicProgramming 动态规划
动态归划，与分治策略类似
- 相同
  - 分解：划分原问题为若干子问题
    - 同类问题，规模更小
    - 新的的问题，但可单独求解
  - 解决
    - 同类问题，求解规模更小的子问题
      - 递归结束：规模最小的同类子问题 可直接得出。
      - 归并：只剩一个元素
      - 快排：只剩一个元素
      - 最大子数组之和：只剩一个元素
    - 不同的问题，单独求解
    - 合并：组合子问题的解，求解原问题
      - 归并：全并操作
      - 最大子数组之和：找出最大值。
- 不同
  - 分治策略：互不相交的子问题。如归并排序、快排、最大子数组之和。
    - 使用递归
  - 动态规划：大量重复的子问题。如钢条切割，最大子数组之各。
    - 使用额外存储空间存储子问题答案，避免重复求解
    - 一般 自底向上
    - 一般不使用递归。使用状态转移方程解决子问题。

状态转移解法步骤
- 设计状态
- 状态转移方程
- 设定初始状态
- 执行状态转移
- 返回最终解


《算法导论》步骤
- 刻画一个最优解的的结构特征
- 递归地定义最优解的值
- 计算最优解的值，通常采用自底向上的方法
- 利用计算出的信息构造一个最优解。

# 钢条切割 CutRod

状态步骤
- 设计状态
  - 分治：划分子问题。子问题是同类问题，或可单独求解。
  - 长度为i的最大值为dp[i],i=[0,n-1]
  - 这些子问题的解可以组合出原问题的解。
- 状态转移方程
  - 切割[0,i-1]
    - 不切割
  - dp[i] = max(nums[i],dp[i-1]+ dp[1], dp[i-2] + dp[2], ..., d[1]+ dp[i-1] );
  - (递归定义子问题解)
- 设定初始状态
  - dp[0] = 0;
  - dp[1] = nums[1];
  - 递归结束条件。
- 执行状态转移
  - 求解子问题解，从1到n
  - 自底向上求解
- 返回最终解
  - 组合子问题的解，求解原问题的解
  - 该题中，子问题的定义就是原问题
  - result = dp[n];
  

- 最优解的结构特征
  - Rn = max(Pn, R1+Rn-1, R2+Rn-2,...,Rn-2+R2,Rn-1+R1)
- 递归地定义最优解的值
- 自底向上
  - 从0开始计算子问题的值
- 构造一个最优解

动态规划核心思想：
- 把原问题划分成独立的子问题。
- 使用额外空间存储子问题的解，避免重复求解子问题。
- 使用子问题解组合成原问题解。

# 最大连续子数组之和

- 把原问题划分成独立的子问题
  - 以第i个元素结尾的子数组的最大子数组和为dp[i]
    - 与第i子元素相连   
      - dp[i-1] + nums[i];
    - 与第i个元素不相连
      - nums[i]
- 使用额外空间存储子问题的解，避免重复求解子问题。
  - 使用dp[nums.size()]存储子问题的解
  - 求解子问题
    - dp[0] = nums[0];//初始状态 ，递归结束条件。
    - dp[i] = max(dp[i - 1] + nums[i], nums[i]);
- 使用子问题解组合成原问题解。
  - max(dp[0], dp[1], dp[2], ... , dp[n-2],dp[n-1]);

[https://leetcode.cn/problems/maximum-subarray/](https://leetcode.cn/problems/maximum-subarray/)

nums[n];
状态步骤
- 设计状态
  - 分治：划分子问题。子问题是同类问题，或可单独求解。
  - 以第i个元素为结尾的子数组的最大子数组和为dp[i],i=[0,n-1]
  - 这些子问题的解可以组合出原问题的解。
- 状态转移方程
  - 与i元素相连 dp[i-1] + nums[i]
  - 与i元素不相连nums[i]
  - dp[i] = max(dp[i-1]+nums[i],nums[i])
  - (递归定义子问题解)
- 设定初始状态
  - dp[0] = nums[0]
  - 递归结束条件。
- 执行状态转移
  - 求解子问题解，从0到n-1
- 返回最终解
  - 组合子问题的解，求解原问题的解
  - result = max(dp[0], dp[1], d[2], ..., dp[n-2], d[n-1]);


```C++
    int maxSubarraySum(vector<int>& nums){
        if(nums.size() == 0){
            return 0;
        }
        vector<int> dp(nums.size());
        int maxValue = nums[0];
        dp[0] = nums[0];
        for(int i = 1; i < nums.size(); ++i){
            dp[i] = max(dp[i-1] + nums[i], nums[i]);
            maxValue = max(maxValue, dp[i]);
        }
        return maxValue;
    }
    int max(int a, int b){
        return a > b ? a : b;
    }
```

# 最大连续子数组

